<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monolith — Structural English Visualizer</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: #0a0a0a;
    color: #e0e0e0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  h1 {
    margin-top: 40px;
    font-size: 2rem;
    letter-spacing: 0.3em;
    color: #fff;
    text-transform: uppercase;
  }

  .subtitle {
    color: #666;
    font-size: 0.85rem;
    margin-top: 4px;
    letter-spacing: 0.1em;
  }

  .input-area {
    margin-top: 40px;
    display: flex;
    gap: 12px;
    width: 90%;
    max-width: 800px;
  }

  textarea {
    flex: 1;
    padding: 14px 20px;
    font-size: 1.05rem;
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 8px;
    color: #fff;
    outline: none;
    transition: border-color 0.3s;
    resize: vertical;
    min-height: 48px;
    max-height: 200px;
    font-family: inherit;
    line-height: 1.5;
  }

  textarea:focus { border-color: #666; }

  button {
    padding: 14px 28px;
    font-size: 1rem;
    background: #fff;
    color: #000;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    letter-spacing: 0.05em;
    transition: background 0.2s;
    align-self: flex-end;
  }

  button:hover { background: #ddd; }
  button:disabled { background: #444; color: #888; cursor: wait; }

  .result-area {
    margin-top: 48px;
    width: 90%;
    max-width: 800px;
    min-height: 100px;
  }

  .sentence-group {
    margin-bottom: 28px;
  }

  .original {
    color: #555;
    font-size: 0.85rem;
    margin-bottom: 10px;
    font-style: italic;
  }

  .blocks-wrap {
    display: flex;
    flex-wrap: wrap;
    align-items: baseline;
    gap: 2px;
  }

  /* Block rendering */
  .block {
    display: inline-flex;
    align-items: baseline;
    flex-wrap: wrap;
    gap: 4px;
    padding: 6px 12px;
    margin: 3px;
    border-radius: 6px;
    border: 2px solid;
    position: relative;
    vertical-align: top;
  }

  .block-text {
    font-size: 1.2rem;
    font-weight: 500;
    line-height: 1.8;
  }

  /* Role icons — only visible in shift mode */
  .block::before {
    font-size: 0.7rem;
    margin-right: 4px;
    opacity: 0;
    transition: opacity 0.15s;
    display: inline;
  }
  .role-S::before  { content: '\f007'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .role-V::before  { content: '\f0e7'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .role-O::before  { content: '\f140'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .role-C::before  { content: '\f52c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .role-M::before  { content: '\f3c5'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .role-CONJ::before { content: '\f219'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .role-REL::before  { content: '\f0c1'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .role-SUB::before  { content: '\f466'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
  .shift-mode::before { opacity: 0.9; }

  /* Role colors — no labels, only colors speak */
  .role-S  { border-color: #4a9eff; background: rgba(74,158,255,0.08); }
  .role-V  { border-color: #ff6b6b; background: rgba(255,107,107,0.08); }
  .role-O  { border-color: #51cf66; background: rgba(81,207,102,0.08); }
  .role-C  { border-color: #ffd43b; background: rgba(255,212,59,0.08); }
  .role-M  { border-color: #b197fc; background: rgba(177,151,252,0.08); }
  .role-CONJ { border-color: #868e96; background: rgba(134,142,150,0.08); }
  .role-REL  { border-color: #ff922b; background: rgba(255,146,43,0.08); }
  .role-SUB  { border-color: #20c997; background: rgba(32,201,151,0.08); }

  .role-S .block-text  { color: #4a9eff; }
  .role-V .block-text  { color: #ff6b6b; }
  .role-O .block-text  { color: #51cf66; }
  .role-C .block-text  { color: #ffd43b; }
  .role-M .block-text  { color: #b197fc; }
  .role-CONJ .block-text { color: #868e96; }
  .role-REL .block-text  { color: #ff922b; }
  .role-SUB .block-text  { color: #20c997; }

  /* Nested blocks get slightly more padding and distinct background */
  .block .block { background: rgba(255,255,255,0.03); }
  .block .block .block { background: rgba(255,255,255,0.05); }

  /* Tooltip */
  .block { position: relative; cursor: default; }
  .block > .tooltip {
    display: none;
    position: absolute;
    bottom: calc(100% + 6px);
    left: 50%;
    transform: translateX(-50%);
    background: #fff;
    color: #111;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 0.85rem;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }
  .block > .tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: #fff;
  }
  .block:hover > .tooltip { display: block; }
  .block.shift-mode > .tooltip { display: none; }

  /* Word-level tooltips */
  .word-span { position: relative; cursor: pointer; }
  .word-span .word-tip {
    display: none;
    position: absolute;
    bottom: calc(100% + 4px);
    left: 50%;
    transform: translateX(-50%);
    background: #ffe066;
    color: #111;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 0.8rem;
    white-space: nowrap;
    z-index: 101;
    pointer-events: none;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  }
  .word-span .word-tip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: #ffe066;
  }
  .shift-mode .word-span:hover .word-tip { display: block; }

  /* Clickable text blocks */
  .block-text { cursor: pointer; transition: opacity 0.15s; }
  .block-text:active { opacity: 0.6; }
  .block-text.speaking { text-decoration: underline; text-decoration-style: dotted; }

  /* Legend */
  .legend {
    margin-top: 48px;
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
    opacity: 0.6;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.8rem;
    position: relative;
    cursor: pointer;
  }

  .legend-item .legend-tip {
    display: none;
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: #fff;
    color: #111;
    padding: 8px 14px;
    border-radius: 8px;
    font-size: 0.78rem;
    line-height: 1.6;
    width: 270px;
    white-space: normal;
    z-index: 200;
    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    pointer-events: none;
  }
  .legend-item .legend-tip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: #fff;
  }
  .legend-item:hover .legend-tip { display: block; }

  .legend-dot {
    width: 12px;
    height: 12px;
    border-radius: 3px;
  }

  .leg-shift { display: none; }
  body.shift-active .leg-shift { display: inline; }
  body.shift-active .leg-normal { display: none; }

  .error { color: #ff6b6b; margin-top: 20px; }

  .loading {
    color: #666;
    font-size: 1.1rem;
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 1; }
  }

  /* History */
  .history {
    margin-top: 60px;
    width: 90%;
    max-width: 800px;
    border-top: 1px solid #222;
    padding-top: 24px;
  }

  .history-entry {
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid #1a1a1a;
  }

  .separator {
    border: none;
    border-top: 1px solid #222;
    margin: 16px 0;
  }
</style>
</head>
<body>

<h1>◼ Monolith</h1>
<p class="subtitle">Structural English Visualizer</p>

<div class="input-area">
  <textarea id="sentence" placeholder="Enter English sentence(s)..." rows="2"></textarea>
  <button id="parseBtn" onclick="parse()">Parse</button>
</div>

<div class="result-area" id="result"></div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#4a9eff"></div><span class="leg-normal">Subject</span><span class="leg-shift"><i class="fas fa-user"></i> 誰が</span><span class="legend-tip">Subject（主語）— 文の主役。「誰が」「何が」動作するのか。英語は必ずここから始まる。</span></div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff6b6b"></div><span class="leg-normal">Verb</span><span class="leg-shift"><i class="fas fa-bolt"></i> どうする</span><span class="legend-tip">Verb（動詞）— 文の心臓。主語が「何をする」のか。これがないと文にならない。</span></div>
  <div class="legend-item"><div class="legend-dot" style="background:#51cf66"></div><span class="leg-normal">Object</span><span class="leg-shift"><i class="fas fa-bullseye"></i> 何を</span><span class="legend-tip">Object（目的語）— 動作の受け手。「何を」「誰を」。動詞の力が向かう先。</span></div>
  <div class="legend-item"><div class="legend-dot" style="background:#ffd43b"></div><span class="leg-normal">Complement</span><span class="leg-shift"><i class="fas fa-equals"></i> ＝何</span><span class="legend-tip">Complement（補語）— イコールの関係。She is a doctor. の「a doctor」のように、主語＝何かを示す。</span></div>
  <div class="legend-item"><div class="legend-dot" style="background:#b197fc"></div><span class="leg-normal">Modifier</span><span class="leg-shift"><i class="fas fa-location-dot"></i> いつ・どこ</span><span class="legend-tip">Modifier（修飾語句）— 追加情報。いつ・どこで・どうやって。なくても文は成り立つが、意味が豊かになる。</span></div>
  <div class="legend-item"><div class="legend-dot" style="background:#20c997"></div><span class="leg-normal">Clause</span><span class="leg-shift"><i class="fas fa-box"></i> 文の中の文</span><span class="legend-tip">Subordinate Clause（従属節）— 「〜ということ」「〜なので」。文の中にもう一つの文が入る入れ子構造。</span></div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff922b"></div><span class="leg-normal">Relative</span><span class="leg-shift"><i class="fas fa-link"></i> 説明する文</span><span class="legend-tip">Relative Clause（関係詞節）— 「〜するところの」。名詞を後ろから説明する文。英語が前から後ろに伸びる感覚の正体。</span></div>
  <div class="legend-item"><div class="legend-dot" style="background:#868e96"></div><span class="leg-normal">Conjunction</span><span class="leg-shift"><i class="fas fa-diamond"></i> つなぎ</span><span class="legend-tip">Conjunction（接続詞）— つなぎ言葉。that, which, because, and など。ブロックとブロックをつなぐ接着剤。</span></div>
</div>

<div class="history" id="history"></div>

<script>
// Shift key tracking for word-level tooltips
let shiftHeld = false;
document.addEventListener('keydown', e => {
  if (e.key === 'Shift' && !shiftHeld) {
    shiftHeld = true;
    document.body.classList.add('shift-active');
    document.querySelectorAll('.block').forEach(b => b.classList.add('shift-mode'));
  }
});
document.addEventListener('keyup', e => {
  if (e.key === 'Shift') {
    shiftHeld = false;
    document.body.classList.remove('shift-active');
    document.querySelectorAll('.block').forEach(b => b.classList.remove('shift-mode'));
  }
});

// TTS via Web Speech API
function speak(text, el) {
  if (!window.speechSynthesis) return;
  window.speechSynthesis.cancel();
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = 'en-US';
  utter.rate = 0.9;
  if (el) {
    el.classList.add('speaking');
    utter.onend = () => el.classList.remove('speaking');
  }
  window.speechSynthesis.speak(utter);
}

const input = document.getElementById('sentence');
const btn = document.getElementById('parseBtn');
const result = document.getElementById('result');
const historyEl = document.getElementById('history');

input.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); parse(); }
});

function renderBlock(block) {
  const el = document.createElement('span');
  el.className = `block role-${block.role || 'M'}`;

  // Tooltip with Japanese translation
  if (block.ja) {
    const tip = document.createElement('span');
    tip.className = 'tooltip';
    tip.textContent = block.ja;
    el.appendChild(tip);
  }

  if (block.children && Array.isArray(block.children)) {
    block.children.forEach(child => el.appendChild(renderBlock(child)));
  } else if (block.text) {
    const txt = document.createElement('span');
    txt.className = 'block-text';
    if (block.words && Array.isArray(block.words)) {
      block.words.forEach((w, i) => {
        const ws = document.createElement('span');
        ws.className = 'word-span';
        ws.textContent = w.en;
        ws.addEventListener('click', (e) => {
          e.stopPropagation();
          if (shiftHeld) {
            speak(w.en, ws);
          } else {
            speak(block.text, txt);
          }
        });
        if (w.ja) {
          const wt = document.createElement('span');
          wt.className = 'word-tip';
          wt.textContent = w.ja;
          ws.appendChild(wt);
        }
        txt.appendChild(ws);
        if (i < block.words.length - 1) txt.appendChild(document.createTextNode(' '));
      });
    } else {
      txt.textContent = block.text;
      txt.addEventListener('click', (e) => { e.stopPropagation(); speak(block.text, txt); });
    }
    el.appendChild(txt);
  }
  return el;
}

function renderSentences(sentences, container) {
  sentences.forEach(s => {
    const group = document.createElement('div');
    group.className = 'sentence-group';

    if (s.text) {
      const orig = document.createElement('div');
      orig.className = 'original';
      orig.textContent = s.text;
      group.appendChild(orig);
    }

    const wrap = document.createElement('div');
    wrap.className = 'blocks-wrap';
    if (Array.isArray(s.blocks)) {
      s.blocks.forEach(b => wrap.appendChild(renderBlock(b)));
    }
    group.appendChild(wrap);
    container.appendChild(group);
  });
}

async function parse() {
  const sentence = input.value.trim();
  if (!sentence) return;

  btn.disabled = true;
  result.innerHTML = '<div class="loading">◼ ◼ ◼</div>';

  try {
    const res = await fetch('/monolith/api/parse', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({sentence})
    });
    const data = await res.json();

    if (data.error) {
      result.innerHTML = `<div class="error">${data.error}</div>`;
      return;
    }

    result.innerHTML = '';
    const sentences = data.sentences || [];
    renderSentences(sentences, result);

    input.value = '';
    input.focus();
  } catch(e) {
    result.innerHTML = `<div class="error">${e.message}</div>`;
  } finally {
    btn.disabled = false;
  }
}
</script>
</body>
</html>
